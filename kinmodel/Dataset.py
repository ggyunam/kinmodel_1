"""Defines the Dataset class.

** Modified by Gyunam Park 24.03.12

"""
import string
import numpy as np


class Dataset:
    def __init__(self, name="", times=None, concs=None):
        self.name = name
        self.times = times
        self.concs = concs

    @property
    def total_data_points(self):
        return self.concs.size - np.isnan(self.concs).sum()

    @property
    def num_times(self):
        return len(self.times)

    @property
    def max_time(self):
        return max(self.times)

    @property # new code
    def min_time(self):
        return self.times[0]

    @property # new code
    def second_time(self):
        return self.times[1]

    @classmethod
    def read_raw_data(cls, model, data_filename) -> ['Dataset']:
        """Load data from file, formated as a csv file.

        File is assumed to have the following structure:
            - Rows with only the first cell filled with a string (not
              interpretable as a number) and the remaining cells empty
              are titles for new datasets, which follow. Each experiment
              must have a title after the first.
            - All rows with the first column interpretable as a number
              are assumed to contain data.
            - All other rows ignored.

        """

        def _is_number(s):
            try:
                float(s)
                return True
            except ValueError:
                return False

        with open(data_filename) as datafile:
            datasets = [cls()]
            all_times = []
            all_concs = []
            curr_ds_times = []
            curr_ds_concs = []
            first_data_line = True
            for line in datafile:
                curline = line.replace("\n", "").split(",")
                if _is_number(curline[0]):
                    # Line contains data
                    if first_data_line:
                        # New code: Comment this paragraph
                        """ 
                        if float(curline[0]) != 0:
                            # Append a t = 0 at the start.
                            curr_ds_times.append(0)
                            line_concs = []
                            for n in range(model.num_data_concs):
                                line_concs.append(np.nan)
                            curr_ds_concs.append(line_concs)
                        """ 
                        first_data_line = False
                    curr_ds_times.append(float(curline[0]))
                    line_concs = []
                    for n in range(model.num_data_concs):
                        if n+1 < len(curline):
                            if curline[n+1] != "":
                                line_concs.append(float(curline[n+1]))
                            else:
                                line_concs.append(np.nan)
                        else:
                            line_concs.append(np.nan)
                    curr_ds_concs.append(line_concs)
                elif curline[0] != '' and curline[1:] == ['']*(len(curline)-1):
                    # Line contains dataset name
                    if curr_ds_times:
                        # A dataset already exists, move on to next one
                        all_times.append(curr_ds_times)
                        all_concs.append(curr_ds_concs)
                        curr_ds_times = []
                        curr_ds_concs = []
                        datasets.append(cls())
                        datasets[-1].name = "".join(
                                c for c in curline[0] if c in string.printable)
                    else:
                        # This is the first dataset
                        datasets[-1].name = "".join(
                                c for c in curline[0] if c in string.printable)
                    first_data_line = True
            # Record times for last dataset
            all_times.append(curr_ds_times)
            all_concs.append(curr_ds_concs)

            # Sort and store data for all datasets
            for s in range(len(datasets)):
                datasets[s].times = np.array(all_times[s])
                unsorted_data = np.array(all_concs[s])
                sorted_data = np.empty_like(unsorted_data)
                for n in range(model.num_data_concs):
                    sorted_data[:, n] = unsorted_data[:, model.sort_order[n]]
                datasets[s].concs = sorted_data

        return datasets

    @classmethod
    def boot_randomX(self, N, datasets, force1st=False) -> [['Dataset']]:
        """Generates datasets using a non-parametric random X bootstrap
        method. Subsets of the data are generated by filling with
        randomly chosen time points from the original data. Returns a
        list of lists of Datasets.
        """
        def sort_data(times, concs):
            sorted_times = np.array(sorted(times))
            sorted_concs = np.array([c for _, c in sorted(
                    list(zip(times, concs)), key=lambda x: x[0])])
            return sorted_times, sorted_concs

        boot_datasets = []
        for i in range(N):
            current_datasets = []
            for d in datasets:
                if force1st:
                    # Always include initial points.
                    new_concs = np.array([d.concs[0]])
                    new_times = np.array([d.times[0]])
                    while len(new_times) < len(d.times):
                        x = np.random.randint(1, d.num_times)
                        new_concs = np.append(new_concs, [d.concs[x]], axis=0)
                        new_times = np.append(new_times, [d.times[x]], axis=0)
                else:
                    new_concs = np.empty((0, len(d.concs[0])))
                    new_times = np.array([])
                    for n in range(0, d.num_times):
                        x = np.random.randint(0, d.num_times)
                        new_concs = np.append(new_concs, [d.concs[x]], axis=0)
                        new_times = np.append(new_times, [d.times[x]], axis=0)
                sorted_times, sorted_concs = sort_data(new_times, new_concs)
                current_datasets.append(Dataset(
                        times=sorted_times, concs=sorted_concs))

            boot_datasets.append(current_datasets)

        return boot_datasets
